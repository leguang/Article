![logo](https://i.imgur.com/DyZZ5vE.png)

# 一声笑Android端架构与技术选型

## 摘要

* [前言](#前言)
* [开发环境](#开发环境)
	* [IDE](#IDE)
	* [工具插件](#工具插件)
* [规范](#规范)
* [Android技术栈](#Android技术栈)
	* [Gradle构建](#Gradle构建)
	* [组件化](#组件化)
	* [模块化](#模块化)
	* [MVP模式](#MVP模式)
	* [UI框架](#UI框架)
	* [依赖](#依赖)
* [代码管理](#代码管理)
* [前后端分离](#前后端分离)
	* [RESTful接口](#RESTful接口) 
	* [URL结构](#URL结构) 
	* [公共请求头](#公共请求头) 
	* [公共参数](#公共参数) 
	* [个性参数](#个性参数) 
	* [公共响应头](#公共响应头) 
	* [公共响应体](#公共响应体) 
	* [HTTP动词表示操作](#HTTP动词表示操作) 
	* [状态码](#状态码) 
	* [分页](#分页) 
* [建议](#建议)

### 前言
由于我司目前处于项目探索阶段，会有较多的项目和迭代，因此快速开发是主旋律，可维护是基调，这就要求代码高可复用、灵活拆分、便于调试，基于这些原因我将根据经验对Android开发架构和技术选型进行梳理。这份文档可看做我司Android部分项目简介和技术简介。由于时间紧凑，若有遗漏可通过QQ/微信666233联系我询问。

## 开发环境

### IDE
使用Android Studio3.0及以上版本，Android Studio在3.0这一版本改动比较大，功能上增强了不少，起码可以原生使用Lambda，也可以使用Stream流操作集合，这些在数据处理上都是很好的。

### 工具插件
工欲善其事必先利其器，配合好插件事半功倍，以下是几个最常用的，需要安装一下。
- GsonFormat
- Translation
- CodeGlance
- Android Drawable Importer
- folding-plugin
- Android Studio Prettify

更多详情请参考：[Android 开发者工具](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0526/7973.html)。

## 规范
一名二姓三风水，四积阴德五读书，名不正则言不顺，言不顺则事难成。软件开发其实就是门命名的艺术，所以首先定义一些规范，提出一些硬性要求，大家在命名的时候尽量多花点心思，多参考优秀的命名风格（强烈推荐参考：[阿里巴巴Java开发手册](https://github.com/leguang/Article/blob/master/阿里巴巴Android开发手册.pdf)），以利于项目维护、增强代码可读性、提升 Code Review 效率以及规范团队协作开发，让我们按照规范自成方圆，具体请参考：[Android开发规范](https://github.com/leguang/Article/blob/master/Android开发规范/Android开发规范.md)。同时开源配合阿里巴巴开源的java代码规范检测插件，尽量做到各个维度的规范。
* 一个单词尽量选择5--7个字母的，这样才最优美。
* 首字母缩写的单词尽量每个字母都用大写，例如ID。用个小写，人家还以为是一个单词。当然uri、url、urn这种除外，因为大家都知道这个是什么。
* 前后端的某些名称概念要统一用某一个单词，比如支付的统一订单，支付宝用的是order，微信用的是unifiedorder，那我们统一对订单这个概念用order这个词。再比如主机：后台用gateway，现在我们统一用host。这单词不统一很容易分裂。

## Android技术栈
### Gradle构建
对Gradle的配置要求：
* 对于编译版本和依赖版本等进行统一管理。
* 尽量分为debug版本和release版本。
* 能自动处理版本号。
* 配置多渠道打包。
* 自定义输出各类Apk文件名称。
* 尽量通过配置Gradle的形式配置第三方Key。
* 通过productFlavors构建不同的渠的App（应用场景有很多，比如应用商店的加壳）。

### 组件化
组件是指项目开发中能作为一个独立功能的部分。我们平时开发中尽量将独立功能的部分（例如某一个自定义View，或者某个工具类等）抽取出来做成组件，然后发布到jcenter、jitpack或者私有服务器上，平时开发的时候就直接在Gradle里配置依赖即可，目的也是为了快速开发和充分复用。

### 模块化
首先模块化的目的除了为了快速开发和复用代码外，更为了在项目逐渐庞大起来后能灵活协作开发和单独调试，耦合度降低便于拆分组合。根据以往经验，我将整体架构分为5层（并不一定要分这么多层），其关系应该是如下图所示：

![架构图](https://i.imgur.com/IwjarzT.png)

整体架构从上依赖至下，下层为上层提供服务。架构的设计主要是为了应对我们公司自身业务探索时快速开发，在不断的开发过程中汲取可用部分抽象整理成独立的模块以方便后续使用。同时模块的划分也根据不同的功能和业务划分到不同的层级中。理论上来说可以有一个集成代码库，然后从这一套代码中通过差异化的构建，编译出不同的App，缺点是代码库会越来越大，组件越来越多，模块也越来越多。如果单独根据项目来集成又会出现多套相同代码需要维护的问题，这个得根据业务需求和是否需要长期维护等因素适当取舍才行。根据Android项目的目录特点，每一个项目在创建出来会有一个App module，这个module我们当做一个空壳，单独依赖main层，只根据需求写Gradle配置而已。模块之间的通讯通过ARouter进行，或者可以自己在ACommon层定义接口的方式进行通讯。

### MVP模式
MVC/MVP/MVVM模式有很多，这里所说的也不是纯粹的MVP，应该是MVP和MVVM混合体的改造版，目的还是为了充分解耦和方便调试。同时为了方便调试，各层之间完全依赖接口，如下图所示：

![MVP模式](https://i.imgur.com/UgFvZJg.jpg)

同时由于我们强调组件化、模块化，可以总结为按业务分模块，按功能分组件，按MVP分层。

### UI框架
为了取得更好的性能，页面更好的管理，整体UI框架以多Activity+多Fragment的形式搭建，界面经历优先选择使用Fragment，Activity只做Fragment的容器，同时Fragment做为MVP模式中的View层。使用了Fragmentation这个框架来操作Fragment，这样合理的控制Activity个数，也使得界面更轻量级。

### 依赖
公共依赖配置在abse module的build.gradle里，其他特殊需求的依赖配置在main module的build.gradle中，可自行到Github上查看学习。
- 网络访问框架：OkHttp、Retrofit配合RxJava2。
- 图片加载框架：Glide、Fresco、Picasso。
- 缓存框架：DiskLruCache、 Robospice。
- Json解析框架：Gson、Fastjson、Jackson。
- 事件总线：EventBus。
- ORM框架：Litepal、Room。
- 数据统计：友盟统计，百度统计。
- 奔溃搜集：腾讯Bugly、Bugtags。
- 云存储：七牛。
- 即使通讯：环信、融云、阿里百川。
- 推送：小米推送、华为推送、腾讯推送、阿里云推送。
- 安全加固：360加固宝、爱加密。
- 还有其他各种各样开源的自定义控件、动画等。除了以上提到的开源框架，也包括一些不开源的SDK。

需要注意的是在引入第三方库的时候应做好充分调查。

## 代码管理
统一使用git进行管理。

## 前后端分离
理论上在立项之后，由于前面的充分准备，加上模块化的开发，前期在UI图还没拿到手之前，就能将一个App最初期的任务如项目搭建、闪屏页、欢迎页、注册登录、个人信息、设置等常规模块通过引人的方式快速完成。之后再根据接口约束开发，不需要等着后台接口做好再动手。

### RESTful接口
RESTful接口是时下流行接口规范，前后端都有很多优秀的框架完成这种规范，这样大家都能减少沟通成本。提前定义好接口和数据内容，可以使用Swagger来管理（配合Postman）接口，前端基于假数据开发，只要符合规范即可，最后正式版也只需要改基地址而已。同时也有一些要求如下：

URI表示资源，资源一般对应服务器端领域模型中的实体类，要求如下：
* 不用大写
* 尽量不用横杠分隔符，万一要用，请使用中杠-不用下杠_
* 参数列表要encode
* URI中的名词表示资源集合，使用复数形式
* 路径仅表示资源的路径（位置），以及一些特殊的actions操作。
* 以复数（名词）进行命名资源，不管返回单个或者多个资源。
* 资源的路径从父到子依次如：/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}/{sub_resource_property}。
* 使用?来进行资源的过滤、搜索以及分页等。
* 使用版本号，且版本号在资源路径之前。
* 优先使用内容协商来区分表述格式，而不是使用后缀来区分表述格式。
* url最好越简短越好，结果过滤，排序，搜索相关的功能都应该通过参数实现。
* url失效则返回404 not found 或 410 gone；对迁移的API，返回 301 重定向。

Json的数据格式，要求如下：
* 不要使用缩写
* 统一用驼峰命名法
* 不要使用_或者-
* 用名词复数表示集合类型
* 为了方便以后的扩展兼容，如果返回的是数组，强烈建议用一个包含如items属性的对象进行包裹。如：{"items":[{},{}]}
* 建议对每个字段设置默认值（数组型可设置为[],字符串型可设置为””，数值可设置为0，对象可设置为{}）,这一条是为了方便前端/客户端进行判断字段存不存在操作。
* 建议资源使用UUID最为唯一标识。同时建议命名为id或者uid。
* 采用UTF-8编码。
* 数据应该拿来就能用，不应该还要进行转换操作。

### URL结构
```
https://{serviceRoot}/{collection}/{id}
```
- {serviceRoot} – 域名+端口号 (site URL) + 根目录
- {collection} – 要访问的资源
- {id} – 要访问的资源的唯一编号

### 公共请求头
通过Content-Type指定请求与返回的数据格式有json和xml,暂时我们只管json的。其中请求数据还要指定Accept。
```
Accept: application/json
Content-Type: application/json;charset=UTF-8
```
### 公共参数
公共参数是指每一个接口应该传的参数，同时后端要指定公共参数的默认值，**且要保证没有传公共参数不会报错，所以需要一定的容错性，比如priceDes这个参数值，如果是用的是全部小写的，只要是不冲突，则可认为是准确的参数并且表达了按价格降序排列这个语意**。建议公共参数放到请求头里。

公共参数的位置有以下几种：
* 拼在url后

```
https://xxx.com/products/token=token_G34G34G34G34G35G5
```

* 拼在请求体中

```
{
	"token": "token_G34G34G34G34G35G5",
	其他参数……
}
```
* 放在请求头里

```
	token: token_G34G34G34G34G35G5
	其他参数……
```

|params | 类型 | 描述 |
| - | -| - |
|token | String | 检测权限、标识登录状态 |

### 个性参数
个性参数就是除了公共参数之外的，看能否考虑统一用json浓缩成一个参数，把想要表达的参数通过json中的key-value形式传递。
> 例如：https://xxx.com/ec/v1/search/products?params={"keyword":"方便面","sort":"des"}
或者考虑与业务相关的参数就用json形式包装，而与业务无关的个性参数就还是用传统的方式另立一个参数。
> 例如：https://xxx.com/ec/v1/search/products?limit=10&offset=10&params={"keyword":"方便面","sort":"des"}

### 公共响应头
```
Content-Type:application/json; charset=utf-8
Status:200 OK
```
其中状态码要与公共响应体里的json中的code字段一样。

### 公共响应体
默认会有以下字段，不需要全部都有。
```
{
    "message": "居然被你查询成功了",
    "code": 200,
    "page": 0,
    "pageSize": 20,
    "first": "https://...",
    "next": "https://...",
    "previous": "https://...",
    "last": "https://...",
    "data": {
        "uid": "6565656565665"
    }
}
```
|key | 类型 | 描述 |
| - | -| -|
|message | String | 返回给接口调用者的描述，有可能用于显示到界面上，需要进行国际化处理 |
|code | int | 这个与请求头中的状态码一致，是为了满足部分开发者的习惯 |
|page | int | 分页请求中请求的当前页的页码 |
|pageSize | int | 分页请求中一页的个数，默认为20 |
|first | String | 分页请求中第一页的url ，如果没有则返回空字符串|
|next | String | 分页请求中下一页的url，如果没有则返回空字符串 |
|previous | String | 分页请求中上一页的url，如果没有则返回空字符串 |
|last | String | 分页请求中最后一页的url，如果没有则返回空字符串 |
|data | object | 当前接口的具体数据由该json对象承载 |
|uid | String | **对于每一个资源对象，在返回的时候，都应该返回操作这个资源对象的唯一码** |

### HTTP动词表示操作。
常用的HTTP动词有下面五个（括号里是对应的SQL命令）。
* GET（SELECT）：从服务器取出资源（一项或多项）。
例如:GET /zoos：列出所有动物园。
* POST（CREATE）：在服务器新建一个资源。
例如:POST /zoos：新建一个动物园。
* PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。
例如:PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）。
* DELETE（DELETE）：从服务器删除资源。
例如:DELETE /zoos/ID：删除某个动物园。

### 状态码
作为 API 的设计者，正确的将 API 执行结果和失败原因用清晰简洁的方式传达给客户程序是十分关键的一步。 我们确实可以在 HTTP 的相应内容中描述是否成功，如果出错是因为什么，然而，这就意味着用户需要进行内容解析，才知道执行结果和错误原因。因此，HTTP响应代码可以保证客户端在第一时间用最高效的方式获知 API 运行结果，并采取相应动作。下表列出了比较常用的响应代码。
常用的http状态码及使用场景：

|响应代码|代码含义|
| - | -|
|200|已创建，请求成功且服务器已创建了新的资源。|
|201|是否只显示处于警告状态的应用实例。|
|301|重定向 , 请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。|
|302|重定向 , 请求的网页临时移动到新位置，但求者应继续使用原有位置来进行以后的请求。302 会自动将请求者转到不同的临时位置。|
|304|未修改，自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。|
|400|错误请求 , 服务器不理解请求的语法。|
|401|未授权 , 请求要求进行身份验证。|
|403|已禁止 , 服务器拒绝请求。|
|404|未找到 , 服务器找不到请求的网页。|
|405|方法禁用 , 禁用请求中所指定的方法。|
|406|不接受 , 无法使用请求的内容特性来响应请求的网页。|
|408|请求超时 , 服务器等候请求时超时。|
|410|已删除 , 如果请求的资源已被永久删除，那么，服务器会返回此响应。|
|412|未满足前提条件 , 服务器未满足请求者在请求中设置的其中一个前提条件。|
|415|不支持的媒体类型 , 请求的格式不受请求页面的支持。|
|500|内部服务器错误。|

### 分页
分页适用于GET类型且返回集合数据的请求，根据如下参数进行分页操作。分页返回的数据见公共响应体。

| params | 类型 | 描述 |
| - | -| -|
| page | int | 页码 |
| pageSize | int | 每一页的个数，该值固定 |

## 建议
- 作为一个有追求的程序员，应尽量使用最新的技术。
- 现在Android 4.4以下的手机已经越来越少，几乎可以不用考虑，因此可以把minSdkVersion设置成20。
- 在使用icon的时候，尽量使用矢量图。
- 数据操作可以考虑使用RxJava或者Stream。
- 建议平时养成写备忘录的习惯，想到点什么与产品有关的就快速记下来，开会的时候就一起讨论。































